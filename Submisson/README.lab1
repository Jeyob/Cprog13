/////////////////////////////////////////////////////////////////
//
// Personuppgifter (namn, pnr, epost) på dem som gjort labben
//


/////////////////////////////////////////////////////////////////
//
// 1.1
//
// vad betyder \$* i en makefile? 
Betonar en implicit regel som matchar mot "%" i målmönstret. I vårt fall innebär att $* ersätts mot namet på infilen.
	
// vad gör -Wall och -g ?

-Wall - En kompileringsflagga som talar om att alla varningar ska visas.

-g	- En kompileringsflagga som placerar ut debuginformation som gör det möjligt att debugga programmet.


/////////////////////////////////////////////////////////////////
//
// 1.2 a)
// 
// int powerof(int x, int y) {
//     int res = 1;
//     for (int i = 0; i < y; i++); {
//         res *= x;
//     }
//     return res;
// }
// 
// int main() {
//     int x = 10;
//     int y = 3;
// 
//     int res = powerof(x, y);
// 
//     std::cout << x << " upphöjt till " << y << " är " << res << std::endl;
// 
//     float z = 0.29;
//     int w = (int) (z * x * x);
//     if (z * x * x == 29)
//         std::cout << z << "*" << x * x << " är 29" << std::endl;
//     else
//         std::cout << z << "*" << x * x << " är inte 29" << std::endl;           
// }
// 
// Varför blir värdet på variabeln w inte det man tror (0.29*100)? 
Eftersom värdet på en float lagras som 0.28888889 och inte 0.29 som man kan tro.

// Hur många varv körs for-loopen i funktionen powerof? 
1 varv. Detta eftersom forloopen följs av ett semicolon.

// 1.2 b)
//
// int must_follow_a(char * start, int length, char a, char b) {
//     int nr = 0;
//     for (int i = 0; i < length; i++, ++start) {
//         if (*start == a && *(start + 1) == b) // maintainers note: DANGER!
//             nr += 1;
//     }
//     return nr;
// }
// 
// Dina tre testfall

  void test_a_is_second_to_last( void )
    {
        char vek[] = {'x', 'x', 'a', 'b', 'x'};
        int result = must_follow_a(vek, 4, 'a', 'b');
        TS_ASSERT_EQUALS( result, 1);
    }

    void test_custom_first( void )
    {
        char vek[] = {'x','a','b','c','a','b'};
        int result = must_follow_a(vek, 5,'a','b');
        TS_ASSERT_EQUALS(result,2);
    }

    void test_custom_second (void ) 
    {
        char vek[] = {'b', 'b', 'a', 'b', 'b'};
        int result = must_follow_a(vek, 3, 'a', 'b');
        TS_ASSERT_EQUALS(result,2);
    }

// Varför är det så viktigt att testa randvillkoren?

Det är viktigt att testa randvillkor då problem relaterat till randvärden är vanliga. 

/////////////////////////////////////////////////////////////////
//
// 1.3 
// 
// Bifoga källkoden till din version av A.cpp

#include <iostream>

class A {
public:
    
    A():id(++idGen)
        {
            std::cout << "The default contructor" << std::endl; 
        }
    A(const A & ref): id(++idGen)
        {std::cout << "The copy contructor for id" <<id<< std::endl; }
    ~A() 
        {std::cout << "The destructor for id " << id << std::endl; }
    A(char * s): id(++idGen)
        {std::cout << "Some other constructor " << s << std::endl;
         std::cout << "Some other constructor for id " << id << std::endl; }
    A & operator=(const A & s) 
        {std::cout << "The assignment operator" << std::endl; 
         return *this;}

    int id;
    static int idGen;
};

int A::idGen = 0;

void no_ref(A a) {std::cout<<"Temporary variabel created"<<std::endl;}
void with_ref(const A & a) {std::cout<<"No temporary variabel"<<std::endl;}

int main()
{


    std::cout<<"Line: A a('my name is a');"<<std::endl;
    /* Since this constructur is not explicit, a temporary object can be created */
    A a("my name is a");std::cout<<std::endl;
    std::cout<<"Line: A b = a;"<<std::endl;
    A b = a;std::cout<<std::endl;         // vad är skillnaden
    std::cout<<"Line: A c(a);"<<std::endl; 
    A c(a); std::cout<<std::endl;          // mellan dessa
    std::cout<<"Line: A d;"<<std::endl;
    A d;             // tre tekniker?
    d = a; std::cout<<std::endl;

    std::cout<<"Line: no_ref(a)"<<std::endl;

    no_ref(a);       // Bildas temporära objekt?
                     // Since the objectlife time of a copied varibel
                     // ends before leaving the function, the destructor is called.
    std::cout<<std::endl;

    std::cout<<"Line: with_ref(a)"<<std::endl;
    with_ref(a);     // Bildas temporära objekt?
                     // No call to the destrcutor since a reference is used. 
    std::cout<<std::endl;

    std::cout<<"Line: A *aa = new A[5];"<<std::endl;
    A *aa = new A[5]; //default constructor invocation
    delete aa;       // Vad kommer att hända?
    return 0;
}


// Vad skriver ditt program ut, var förberedd att förklara varför. 

Line: A a('my name is a');
Some other constructor my name is a
Some other constructor for id 1

Line: A b = a;
The copy contructor for id2

Line: A c(a);
The copy contructor for id3

Line: A d;
The default contructor
The assignment operator

Line: no_ref(a)
The copy contructor for id5
Temporary variabel created
The destructor for id 5

Line: with_ref(a)
No temporary variabel

Line: A *aa = new A[5];
The default contructor
The default contructor
The default contructor
The default contructor
The default contructor
The destructor for id 6
Segmenteringsfel (minnesutskrift skapad)

// När frigörs objekten?  
i no_ref metoden samt längre ner när vi anropar delete på aa.

Vidare så frigörs objekten när de går utanför scope. Dvs när main metoden returnerar. 

// När skapas temporära objekt?

I metoden no_ref

//   A b = a;         // vad är skillnaden
//   A c(a);          // mellan dessa
//   A d;             // tre tekniker?
	
Mellan den första och andra finns ingen skillnad, copy konstruktorn anropas.
Den sista raden anropar default konstruktorn.

//   no_ref(a);       // Bildas temporära objekt?
Ja.

//   with_ref(a);     // Bildas temporära objekt?
Nej.

//   delete aa;       // Vad kommer att hända
Programmet kommer krascha. Eftersom aa pekar till ett minnesblock
allokerat via new[] så måste även delete[] användas. Problemet är 
relaterat till när minnet återlämnas till heapen.

/////////////////////////////////////////////////////////////////
//
// struct Data {
//     int x, y, z;
// };  
// 
// Data ** foo(Data ** v, int x) {
//     for (int i = 0; i < x; i++)
//         //if (v[i] != 0)
//             v[i] = new Data;
//     return v;
// }
// 
// int main () {
//     const int size = 5;
//     Data ** v = new Data * [size];
//     Data ** p = foo(v, size);
//     delete [] p;
// }

// Hur ser valgrinds felmeddelande ut?  

jonas@jonas-U35JC:~/KTH/Cprog13/Submisson/1_3$ valgrind --tool=memcheck --leak-check=yes --track-origins=yes ./Data.out
==22489== Memcheck, a memory error detector
==22489== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
==22489== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info
==22489== Command: ./Data.out
==22489== 
==22489== Conditional jump or move depends on uninitialised value(s)
==22489==    at 0x40067F: foo(Data**, int) (in /home/jonas/KTH/Cprog13/Submisson/1_3/Data.out)
==22489==    by 0x4006EC: main (in /home/jonas/KTH/Cprog13/Submisson/1_3/Data.out)
==22489==  Uninitialised value was created by a heap allocation
==22489==    at 0x4C2C037: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==22489==    by 0x4006D7: main (in /home/jonas/KTH/Cprog13/Submisson/1_3/Data.out)
==22489== 
==22489== 
==22489== HEAP SUMMARY:
==22489==     in use at exit: 40 bytes in 1 blocks
==22489==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated
==22489== 
==22489== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
==22489==    at 0x4C2C037: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==22489==    by 0x4006D7: main (in /home/jonas/KTH/Cprog13/Submisson/1_3/Data.out)
==22489== 
==22489== LEAK SUMMARY:
==22489==    definitely lost: 40 bytes in 1 blocks
==22489==    indirectly lost: 0 bytes in 0 blocks
==22489==      possibly lost: 0 bytes in 0 blocks
==22489==    still reachable: 0 bytes in 0 blocks
==22489==         suppressed: 0 bytes in 0 blocks
==22489== 
==22489== For counts of detected and suppressed errors, rerun with: -v
==22489== ERROR SUMMARY: 6 errors from 2 contexts (suppressed: 2 from 2)


// Blir det någon skillnad i hur mycket minne som läcker när man
// kommenterar if-satsen?
 Ja, vi får indirekta minnesblock som går förlorade.
 
 ==22635==    definitely lost: 40 bytes in 1 blocks
 ==22635==    indirectly lost: 60 bytes in 5 blocks


// Borde det ha blivit någon skillnad?
De första 40 byten som går förlorade är pekarna på 8byte varderan (5st)
De andra 60 byten som nu går förlorade är de 5 Data objekten på 12 byte vardera.

Den andra raden tillkommer eftersom If-satsen tidigare såg till att vi inte
initilizerade vektorn (default värdet för ints är 0), därför hade vi enbart pekarna som gick förlorade. 

// Varför läcker programmet fortfarande minne?
Se kommentar ovan..

/////////////////////////////////////////////////////////////////
//
// 1.4
//
// Generellt är det ofta en god idé att låta konstruktorer som
// tar ett argument deklareras som explicit. Varför? Ange ett
// exempel där det annars kan bli dumt.

I kan i vissa fall handla om att man vill skydda sig mot vissa dumma tilldelningar eller situationer där man inte vill att programmet får för sig att skapa temporära objekt som tillåter för vissa jämförelser eller tilldelningar som annars inte är önskvärda.

// operatorn[] måste vara en konstant medlemsfunktion i vissa
// fall. När och varför? Hur kopierar man vektorn?

I de fall man skapar ett const objekt så måste, säg, operatorn[] också 
respektera att man inte får ändra på elementen i objektet. Det är vanligt att man för vissa metoder definerar två metoder med samma signatur, där de skiljs åt genom att den ena respekterar const begränsingen. När man sedan skapar ett const objekt av den klassen så kan kompilatorn avgöra vilken metod det är som ska anropas. 
